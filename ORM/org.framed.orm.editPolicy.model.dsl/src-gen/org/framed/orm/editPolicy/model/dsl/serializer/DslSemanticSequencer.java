/*
 * generated by Xtext 2.10.0
 */
package org.framed.orm.editPolicy.model.dsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import model.AndMappingRule;
import model.AndRule;
import model.CommandNameRule;
import model.Configuration;
import model.FalseRule;
import model.FeatureNameMappingRule;
import model.ImplicationMappingRule;
import model.ImplicationRule;
import model.Mapping;
import model.Model;
import model.ModelPackage;
import model.NotMappingRule;
import model.NotRule;
import model.OrMappingRule;
import model.OrRule;
import model.ParentTypeRule;
import model.Policy;
import model.RelationIsCyclicRule;
import model.RelationIsReflexivRule;
import model.RelationNameRule;
import model.RelationTypesAreEqualRule;
import model.ShapeNameRule;
import model.ShapeTypeRule;
import model.SourceTypeRule;
import model.StepInRule;
import model.TargetTypeRule;
import model.TrueMappingRule;
import model.TrueRule;
import model.TypeExistsRule;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.framed.orm.editPolicy.model.dsl.services.DslGrammarAccess;

@SuppressWarnings("all")
public class DslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ModelPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ModelPackage.AND_MAPPING_RULE:
				sequence_AndMapping(context, (AndMappingRule) semanticObject); 
				return; 
			case ModelPackage.AND_RULE:
				sequence_AndPolicy(context, (AndRule) semanticObject); 
				return; 
			case ModelPackage.COMMAND_NAME_RULE:
				sequence_CommandNameRule(context, (CommandNameRule) semanticObject); 
				return; 
			case ModelPackage.CONFIGURATION:
				sequence_Configuration(context, (Configuration) semanticObject); 
				return; 
			case ModelPackage.FALSE_RULE:
				sequence_FalseRule(context, (FalseRule) semanticObject); 
				return; 
			case ModelPackage.FEATURE_NAME_MAPPING_RULE:
				sequence_FeatureNameMappingRule(context, (FeatureNameMappingRule) semanticObject); 
				return; 
			case ModelPackage.IMPLICATION_MAPPING_RULE:
				sequence_ImplicationMapping(context, (ImplicationMappingRule) semanticObject); 
				return; 
			case ModelPackage.IMPLICATION_RULE:
				sequence_ImplicationPolicy(context, (ImplicationRule) semanticObject); 
				return; 
			case ModelPackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case ModelPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			case ModelPackage.NOT_MAPPING_RULE:
				sequence_NotMappingExpression(context, (NotMappingRule) semanticObject); 
				return; 
			case ModelPackage.NOT_RULE:
				sequence_NotExpression(context, (NotRule) semanticObject); 
				return; 
			case ModelPackage.OR_MAPPING_RULE:
				sequence_OrMapping(context, (OrMappingRule) semanticObject); 
				return; 
			case ModelPackage.OR_RULE:
				sequence_OrPolicy(context, (OrRule) semanticObject); 
				return; 
			case ModelPackage.PARENT_TYPE_RULE:
				sequence_ParentTypeRule(context, (ParentTypeRule) semanticObject); 
				return; 
			case ModelPackage.POLICY:
				sequence_Policy(context, (Policy) semanticObject); 
				return; 
			case ModelPackage.RELATION_IS_CYCLIC_RULE:
				sequence_RelationIsCyclicRule(context, (RelationIsCyclicRule) semanticObject); 
				return; 
			case ModelPackage.RELATION_IS_REFLEXIV_RULE:
				sequence_RelationIsReflexivRule(context, (RelationIsReflexivRule) semanticObject); 
				return; 
			case ModelPackage.RELATION_NAME_RULE:
				sequence_RelationNameRule(context, (RelationNameRule) semanticObject); 
				return; 
			case ModelPackage.RELATION_TYPES_ARE_EQUAL_RULE:
				sequence_RelationTypesAreEqualRule(context, (RelationTypesAreEqualRule) semanticObject); 
				return; 
			case ModelPackage.SHAPE_NAME_RULE:
				sequence_ShapeNameRule(context, (ShapeNameRule) semanticObject); 
				return; 
			case ModelPackage.SHAPE_TYPE_RULE:
				sequence_ShapeTypeRule(context, (ShapeTypeRule) semanticObject); 
				return; 
			case ModelPackage.SOURCE_TYPE_RULE:
				sequence_SourceTypeRule(context, (SourceTypeRule) semanticObject); 
				return; 
			case ModelPackage.STEP_IN_RULE:
				sequence_StepInRule(context, (StepInRule) semanticObject); 
				return; 
			case ModelPackage.TARGET_TYPE_RULE:
				sequence_TargetTypeRule(context, (TargetTypeRule) semanticObject); 
				return; 
			case ModelPackage.TRUE_MAPPING_RULE:
				sequence_TrueMappingRule(context, (TrueMappingRule) semanticObject); 
				return; 
			case ModelPackage.TRUE_RULE:
				sequence_TrueRule(context, (TrueRule) semanticObject); 
				return; 
			case ModelPackage.TYPE_EXISTS_RULE:
				sequence_TypeExistsRule(context, (TypeExistsRule) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     MappingExpression returns AndMappingRule
	 *     ImplicationMapping returns AndMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns AndMappingRule
	 *     OrMapping returns AndMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns AndMappingRule
	 *     AndMapping returns AndMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns AndMappingRule
	 *     NotMappingExpression returns AndMappingRule
	 *     PrimaryMapping returns AndMappingRule
	 *
	 * Constraint:
	 *     (rules+=AndMapping_AndMappingRule_1_0 rules+=NotMappingExpression)
	 */
	protected void sequence_AndMapping(ISerializationContext context, AndMappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyExpression returns AndRule
	 *     ImplicationPolicy returns AndRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns AndRule
	 *     OrPolicy returns AndRule
	 *     OrPolicy.OrRule_1_0 returns AndRule
	 *     AndPolicy returns AndRule
	 *     AndPolicy.AndRule_1_0 returns AndRule
	 *     NotExpression returns AndRule
	 *     Primary returns AndRule
	 *
	 * Constraint:
	 *     (rules+=AndPolicy_AndRule_1_0 rules+=NotExpression)
	 */
	protected void sequence_AndPolicy(ISerializationContext context, AndRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns CommandNameRule
	 *     AbstractRule returns CommandNameRule
	 *     CommandNameRule returns CommandNameRule
	 *     PolicyExpression returns CommandNameRule
	 *     ImplicationPolicy returns CommandNameRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns CommandNameRule
	 *     OrPolicy returns CommandNameRule
	 *     OrPolicy.OrRule_1_0 returns CommandNameRule
	 *     AndPolicy returns CommandNameRule
	 *     AndPolicy.AndRule_1_0 returns CommandNameRule
	 *     NotExpression returns CommandNameRule
	 *     Primary returns CommandNameRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_CommandNameRule(ISerializationContext context, CommandNameRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCommandNameRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Configuration returns Configuration
	 *
	 * Constraint:
	 *     (mappings+=Mapping mappings+=Mapping*)?
	 */
	protected void sequence_Configuration(ISerializationContext context, Configuration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns FalseRule
	 *     AbstractRule returns FalseRule
	 *     FalseRule returns FalseRule
	 *     PolicyExpression returns FalseRule
	 *     ImplicationPolicy returns FalseRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns FalseRule
	 *     OrPolicy returns FalseRule
	 *     OrPolicy.OrRule_1_0 returns FalseRule
	 *     AndPolicy returns FalseRule
	 *     AndPolicy.AndRule_1_0 returns FalseRule
	 *     NotExpression returns FalseRule
	 *     Primary returns FalseRule
	 *
	 * Constraint:
	 *     {FalseRule}
	 */
	protected void sequence_FalseRule(ISerializationContext context, FalseRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingRule returns FeatureNameMappingRule
	 *     AbstractMappingRule returns FeatureNameMappingRule
	 *     FeatureNameMappingRule returns FeatureNameMappingRule
	 *     MappingExpression returns FeatureNameMappingRule
	 *     ImplicationMapping returns FeatureNameMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns FeatureNameMappingRule
	 *     OrMapping returns FeatureNameMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns FeatureNameMappingRule
	 *     AndMapping returns FeatureNameMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns FeatureNameMappingRule
	 *     NotMappingExpression returns FeatureNameMappingRule
	 *     PrimaryMapping returns FeatureNameMappingRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_FeatureNameMappingRule(ISerializationContext context, FeatureNameMappingRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.FEATURE_NAME_MAPPING_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.FEATURE_NAME_MAPPING_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFeatureNameMappingRuleAccess().getNameEStringParserRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingExpression returns ImplicationMappingRule
	 *     ImplicationMapping returns ImplicationMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns ImplicationMappingRule
	 *     OrMapping returns ImplicationMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns ImplicationMappingRule
	 *     AndMapping returns ImplicationMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns ImplicationMappingRule
	 *     NotMappingExpression returns ImplicationMappingRule
	 *     PrimaryMapping returns ImplicationMappingRule
	 *
	 * Constraint:
	 *     (antecedent=ImplicationMapping_ImplicationMappingRule_1_0 consequent=OrMapping)
	 */
	protected void sequence_ImplicationMapping(ISerializationContext context, ImplicationMappingRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPLICATION_MAPPING_RULE__ANTECEDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPLICATION_MAPPING_RULE__ANTECEDENT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPLICATION_MAPPING_RULE__CONSEQUENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPLICATION_MAPPING_RULE__CONSEQUENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplicationMappingAccess().getImplicationMappingRuleAntecedentAction_1_0(), semanticObject.getAntecedent());
		feeder.accept(grammarAccess.getImplicationMappingAccess().getConsequentOrMappingParserRuleCall_1_2_0(), semanticObject.getConsequent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyExpression returns ImplicationRule
	 *     ImplicationPolicy returns ImplicationRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns ImplicationRule
	 *     OrPolicy returns ImplicationRule
	 *     OrPolicy.OrRule_1_0 returns ImplicationRule
	 *     AndPolicy returns ImplicationRule
	 *     AndPolicy.AndRule_1_0 returns ImplicationRule
	 *     NotExpression returns ImplicationRule
	 *     Primary returns ImplicationRule
	 *
	 * Constraint:
	 *     (antecedent=ImplicationPolicy_ImplicationRule_1_0 consequent=OrPolicy)
	 */
	protected void sequence_ImplicationPolicy(ISerializationContext context, ImplicationRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPLICATION_RULE__ANTECEDENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPLICATION_RULE__ANTECEDENT));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.IMPLICATION_RULE__CONSEQUENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.IMPLICATION_RULE__CONSEQUENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getImplicationPolicyAccess().getImplicationRuleAntecedentAction_1_0(), semanticObject.getAntecedent());
		feeder.accept(grammarAccess.getImplicationPolicyAccess().getConsequentOrPolicyParserRuleCall_1_2_0(), semanticObject.getConsequent());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (rule=MappingExpression policy=[Policy|ID])
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MAPPING__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MAPPING__RULE));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.MAPPING__POLICY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.MAPPING__POLICY));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMappingAccess().getRuleMappingExpressionParserRuleCall_0_0(), semanticObject.getRule());
		feeder.accept(grammarAccess.getMappingAccess().getPolicyPolicyIDTerminalRuleCall_2_0_1(), semanticObject.getPolicy());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (configuration=Configuration (policies+=Policy policies+=Policy*)?)
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyExpression returns NotRule
	 *     ImplicationPolicy returns NotRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns NotRule
	 *     OrPolicy returns NotRule
	 *     OrPolicy.OrRule_1_0 returns NotRule
	 *     AndPolicy returns NotRule
	 *     AndPolicy.AndRule_1_0 returns NotRule
	 *     NotExpression returns NotRule
	 *     Primary returns NotRule
	 *
	 * Constraint:
	 *     rule=Primary
	 */
	protected void sequence_NotExpression(ISerializationContext context, NotRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NOT_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NOT_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotExpressionAccess().getRulePrimaryParserRuleCall_1_2_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingExpression returns NotMappingRule
	 *     ImplicationMapping returns NotMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns NotMappingRule
	 *     OrMapping returns NotMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns NotMappingRule
	 *     AndMapping returns NotMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns NotMappingRule
	 *     NotMappingExpression returns NotMappingRule
	 *     PrimaryMapping returns NotMappingRule
	 *
	 * Constraint:
	 *     rule=PrimaryMapping
	 */
	protected void sequence_NotMappingExpression(ISerializationContext context, NotMappingRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.NOT_MAPPING_RULE__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.NOT_MAPPING_RULE__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNotMappingExpressionAccess().getRulePrimaryMappingParserRuleCall_1_2_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingExpression returns OrMappingRule
	 *     ImplicationMapping returns OrMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns OrMappingRule
	 *     OrMapping returns OrMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns OrMappingRule
	 *     AndMapping returns OrMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns OrMappingRule
	 *     NotMappingExpression returns OrMappingRule
	 *     PrimaryMapping returns OrMappingRule
	 *
	 * Constraint:
	 *     (rules+=OrMapping_OrMappingRule_1_0 rules+=AndMapping)
	 */
	protected void sequence_OrMapping(ISerializationContext context, OrMappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyExpression returns OrRule
	 *     ImplicationPolicy returns OrRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns OrRule
	 *     OrPolicy returns OrRule
	 *     OrPolicy.OrRule_1_0 returns OrRule
	 *     AndPolicy returns OrRule
	 *     AndPolicy.AndRule_1_0 returns OrRule
	 *     NotExpression returns OrRule
	 *     Primary returns OrRule
	 *
	 * Constraint:
	 *     (rules+=OrPolicy_OrRule_1_0 rules+=AndPolicy)
	 */
	protected void sequence_OrPolicy(ISerializationContext context, OrRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns ParentTypeRule
	 *     AbstractRule returns ParentTypeRule
	 *     ParentTypeRule returns ParentTypeRule
	 *     PolicyExpression returns ParentTypeRule
	 *     ImplicationPolicy returns ParentTypeRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns ParentTypeRule
	 *     OrPolicy returns ParentTypeRule
	 *     OrPolicy.OrRule_1_0 returns ParentTypeRule
	 *     AndPolicy returns ParentTypeRule
	 *     AndPolicy.AndRule_1_0 returns ParentTypeRule
	 *     NotExpression returns ParentTypeRule
	 *     Primary returns ParentTypeRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ParentTypeRule(ISerializationContext context, ParentTypeRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParentTypeRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Policy returns Policy
	 *
	 * Constraint:
	 *     (name=ID rule=PolicyExpression)
	 */
	protected void sequence_Policy(ISerializationContext context, Policy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.POLICY__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.POLICY__NAME));
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.POLICY__RULE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.POLICY__RULE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPolicyAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getPolicyAccess().getRulePolicyExpressionParserRuleCall_2_0(), semanticObject.getRule());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns RelationIsCyclicRule
	 *     AbstractRule returns RelationIsCyclicRule
	 *     RelationIsCyclicRule returns RelationIsCyclicRule
	 *     PolicyExpression returns RelationIsCyclicRule
	 *     ImplicationPolicy returns RelationIsCyclicRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns RelationIsCyclicRule
	 *     OrPolicy returns RelationIsCyclicRule
	 *     OrPolicy.OrRule_1_0 returns RelationIsCyclicRule
	 *     AndPolicy returns RelationIsCyclicRule
	 *     AndPolicy.AndRule_1_0 returns RelationIsCyclicRule
	 *     NotExpression returns RelationIsCyclicRule
	 *     Primary returns RelationIsCyclicRule
	 *
	 * Constraint:
	 *     {RelationIsCyclicRule}
	 */
	protected void sequence_RelationIsCyclicRule(ISerializationContext context, RelationIsCyclicRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns RelationIsReflexivRule
	 *     AbstractRule returns RelationIsReflexivRule
	 *     RelationIsReflexivRule returns RelationIsReflexivRule
	 *     PolicyExpression returns RelationIsReflexivRule
	 *     ImplicationPolicy returns RelationIsReflexivRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns RelationIsReflexivRule
	 *     OrPolicy returns RelationIsReflexivRule
	 *     OrPolicy.OrRule_1_0 returns RelationIsReflexivRule
	 *     AndPolicy returns RelationIsReflexivRule
	 *     AndPolicy.AndRule_1_0 returns RelationIsReflexivRule
	 *     NotExpression returns RelationIsReflexivRule
	 *     Primary returns RelationIsReflexivRule
	 *
	 * Constraint:
	 *     {RelationIsReflexivRule}
	 */
	protected void sequence_RelationIsReflexivRule(ISerializationContext context, RelationIsReflexivRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns RelationNameRule
	 *     AbstractRule returns RelationNameRule
	 *     RelationNameRule returns RelationNameRule
	 *     PolicyExpression returns RelationNameRule
	 *     ImplicationPolicy returns RelationNameRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns RelationNameRule
	 *     OrPolicy returns RelationNameRule
	 *     OrPolicy.OrRule_1_0 returns RelationNameRule
	 *     AndPolicy returns RelationNameRule
	 *     AndPolicy.AndRule_1_0 returns RelationNameRule
	 *     NotExpression returns RelationNameRule
	 *     Primary returns RelationNameRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_RelationNameRule(ISerializationContext context, RelationNameRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRelationNameRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns RelationTypesAreEqualRule
	 *     AbstractRule returns RelationTypesAreEqualRule
	 *     RelationTypesAreEqualRule returns RelationTypesAreEqualRule
	 *     PolicyExpression returns RelationTypesAreEqualRule
	 *     ImplicationPolicy returns RelationTypesAreEqualRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns RelationTypesAreEqualRule
	 *     OrPolicy returns RelationTypesAreEqualRule
	 *     OrPolicy.OrRule_1_0 returns RelationTypesAreEqualRule
	 *     AndPolicy returns RelationTypesAreEqualRule
	 *     AndPolicy.AndRule_1_0 returns RelationTypesAreEqualRule
	 *     NotExpression returns RelationTypesAreEqualRule
	 *     Primary returns RelationTypesAreEqualRule
	 *
	 * Constraint:
	 *     {RelationTypesAreEqualRule}
	 */
	protected void sequence_RelationTypesAreEqualRule(ISerializationContext context, RelationTypesAreEqualRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns ShapeNameRule
	 *     AbstractRule returns ShapeNameRule
	 *     ShapeNameRule returns ShapeNameRule
	 *     PolicyExpression returns ShapeNameRule
	 *     ImplicationPolicy returns ShapeNameRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns ShapeNameRule
	 *     OrPolicy returns ShapeNameRule
	 *     OrPolicy.OrRule_1_0 returns ShapeNameRule
	 *     AndPolicy returns ShapeNameRule
	 *     AndPolicy.AndRule_1_0 returns ShapeNameRule
	 *     NotExpression returns ShapeNameRule
	 *     Primary returns ShapeNameRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ShapeNameRule(ISerializationContext context, ShapeNameRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShapeNameRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns ShapeTypeRule
	 *     AbstractRule returns ShapeTypeRule
	 *     ShapeTypeRule returns ShapeTypeRule
	 *     PolicyExpression returns ShapeTypeRule
	 *     ImplicationPolicy returns ShapeTypeRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns ShapeTypeRule
	 *     OrPolicy returns ShapeTypeRule
	 *     OrPolicy.OrRule_1_0 returns ShapeTypeRule
	 *     AndPolicy returns ShapeTypeRule
	 *     AndPolicy.AndRule_1_0 returns ShapeTypeRule
	 *     NotExpression returns ShapeTypeRule
	 *     Primary returns ShapeTypeRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_ShapeTypeRule(ISerializationContext context, ShapeTypeRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getShapeTypeRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns SourceTypeRule
	 *     AbstractRule returns SourceTypeRule
	 *     SourceTypeRule returns SourceTypeRule
	 *     PolicyExpression returns SourceTypeRule
	 *     ImplicationPolicy returns SourceTypeRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns SourceTypeRule
	 *     OrPolicy returns SourceTypeRule
	 *     OrPolicy.OrRule_1_0 returns SourceTypeRule
	 *     AndPolicy returns SourceTypeRule
	 *     AndPolicy.AndRule_1_0 returns SourceTypeRule
	 *     NotExpression returns SourceTypeRule
	 *     Primary returns SourceTypeRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_SourceTypeRule(ISerializationContext context, SourceTypeRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSourceTypeRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns StepInRule
	 *     AbstractRule returns StepInRule
	 *     StepInRule returns StepInRule
	 *     PolicyExpression returns StepInRule
	 *     ImplicationPolicy returns StepInRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns StepInRule
	 *     OrPolicy returns StepInRule
	 *     OrPolicy.OrRule_1_0 returns StepInRule
	 *     AndPolicy returns StepInRule
	 *     AndPolicy.AndRule_1_0 returns StepInRule
	 *     NotExpression returns StepInRule
	 *     Primary returns StepInRule
	 *
	 * Constraint:
	 *     {StepInRule}
	 */
	protected void sequence_StepInRule(ISerializationContext context, StepInRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns TargetTypeRule
	 *     AbstractRule returns TargetTypeRule
	 *     TargetTypeRule returns TargetTypeRule
	 *     PolicyExpression returns TargetTypeRule
	 *     ImplicationPolicy returns TargetTypeRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns TargetTypeRule
	 *     OrPolicy returns TargetTypeRule
	 *     OrPolicy.OrRule_1_0 returns TargetTypeRule
	 *     AndPolicy returns TargetTypeRule
	 *     AndPolicy.AndRule_1_0 returns TargetTypeRule
	 *     NotExpression returns TargetTypeRule
	 *     Primary returns TargetTypeRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_TargetTypeRule(ISerializationContext context, TargetTypeRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTargetTypeRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MappingRule returns TrueMappingRule
	 *     AbstractMappingRule returns TrueMappingRule
	 *     TrueMappingRule returns TrueMappingRule
	 *     MappingExpression returns TrueMappingRule
	 *     ImplicationMapping returns TrueMappingRule
	 *     ImplicationMapping.ImplicationMappingRule_1_0 returns TrueMappingRule
	 *     OrMapping returns TrueMappingRule
	 *     OrMapping.OrMappingRule_1_0 returns TrueMappingRule
	 *     AndMapping returns TrueMappingRule
	 *     AndMapping.AndMappingRule_1_0 returns TrueMappingRule
	 *     NotMappingExpression returns TrueMappingRule
	 *     PrimaryMapping returns TrueMappingRule
	 *
	 * Constraint:
	 *     {TrueMappingRule}
	 */
	protected void sequence_TrueMappingRule(ISerializationContext context, TrueMappingRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns TrueRule
	 *     AbstractRule returns TrueRule
	 *     TrueRule returns TrueRule
	 *     PolicyExpression returns TrueRule
	 *     ImplicationPolicy returns TrueRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns TrueRule
	 *     OrPolicy returns TrueRule
	 *     OrPolicy.OrRule_1_0 returns TrueRule
	 *     AndPolicy returns TrueRule
	 *     AndPolicy.AndRule_1_0 returns TrueRule
	 *     NotExpression returns TrueRule
	 *     Primary returns TrueRule
	 *
	 * Constraint:
	 *     {TrueRule}
	 */
	protected void sequence_TrueRule(ISerializationContext context, TrueRule semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PolicyRule returns TypeExistsRule
	 *     AbstractRule returns TypeExistsRule
	 *     TypeExistsRule returns TypeExistsRule
	 *     PolicyExpression returns TypeExistsRule
	 *     ImplicationPolicy returns TypeExistsRule
	 *     ImplicationPolicy.ImplicationRule_1_0 returns TypeExistsRule
	 *     OrPolicy returns TypeExistsRule
	 *     OrPolicy.OrRule_1_0 returns TypeExistsRule
	 *     AndPolicy returns TypeExistsRule
	 *     AndPolicy.AndRule_1_0 returns TypeExistsRule
	 *     NotExpression returns TypeExistsRule
	 *     Primary returns TypeExistsRule
	 *
	 * Constraint:
	 *     name=EString
	 */
	protected void sequence_TypeExistsRule(ISerializationContext context, TypeExistsRule semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ModelPackage.Literals.ABSTRACT_NAME_RULE__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTypeExistsRuleAccess().getNameEStringParserRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
