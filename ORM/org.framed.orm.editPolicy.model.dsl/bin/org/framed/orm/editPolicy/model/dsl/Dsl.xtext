// automatically generated by Xtext
grammar org.framed.orm.editPolicy.model.dsl.Dsl with org.eclipse.xtext.common.Terminals hidden(WS, ML_COMMENT, SL_COMMENT)

import "platform:/resource/org.framed.orm.editPolicy.model/" 
import "http://www.eclipse.org/emf/2002/Ecore" as ecore

Model returns Model:
	configuration=Configuration
	(policies+=Policy (policies+=Policy)*)?;
	
//add new policyrules here
PolicyRule returns AbstractRule:
	TrueRule | FalseRule | CommandNameRule | ShapeTypeRule | ParentTypeRule | StepInRule | SourceTypeRule | TargetTypeRule |
	RelationIsCyclicRule | RelationIsReflexivRule | RelationTypesAreEqualRule | TypeExistsRule | ShapeNameRule 
	| RelationNameRule;
	
AbstractRule returns AbstractRule:
	PolicyRule;
	
//add new mapping rules here
MappingRule returns AbstractMappingRule:
	FeatureNameMappingRule | TrueMappingRule;
		
AbstractMappingRule returns AbstractMappingRule:
	 MappingRule;

Configuration returns Configuration:
	{Configuration} (mappings+=Mapping (mappings+=Mapping)*)?;

Policy returns Policy:
	name=ID ':' rule=PolicyExpression;

Mapping returns Mapping:
	rule=MappingExpression ":" policy=[Policy|ID];

FeatureNameMappingRule returns FeatureNameMappingRule:
	{FeatureNameMappingRule} name=EString;

TrueMappingRule returns TrueMappingRule:
	{TrueMappingRule} 'true';
	
RelationIsCyclicRule returns RelationIsCyclicRule:
	{RelationIsCyclicRule}
	'RelationIsCyclic';

RelationTypesAreEqualRule returns RelationTypesAreEqualRule:
	{RelationTypesAreEqualRule}
	'RelationTypesAreEqual';
	
RelationIsReflexivRule returns RelationIsReflexivRule:
	{RelationIsReflexivRule}
	'RelationIsReflexiv';

EString returns ecore::EString:
	STRING | ID;

RelationNameRule returns RelationNameRule:
	{RelationNameRule}
	'RelationName'
	name=EString;
	
TypeExistsRule returns TypeExistsRule:
	{TypeExistsRule}
	'TypeExists'
	name=EString;

SourceTypeRule returns SourceTypeRule:
	{SourceTypeRule}
	'SourceType'
	name=EString;

TargetTypeRule returns TargetTypeRule:
	{TargetTypeRule}
	'TargetType'
	name=EString;

CommandNameRule returns CommandNameRule:
	{CommandNameRule}
	'CommandName' name=EString;

ShapeTypeRule returns ShapeTypeRule:
	{ShapeTypeRule}
	'ShapeType' name=EString;

ParentTypeRule returns ParentTypeRule:
	{ParentTypeRule}
	'ParentType' name=EString;

StepInRule returns StepInRule:
	{StepInRule}
	'StepIn';

TrueRule returns TrueRule:
	{TrueRule}
	'true';

FalseRule returns FalseRule:
	{FalseRule}
	'false';

ShapeNameRule returns ShapeNameRule:
	{ShapeNameRule}
	'ShapeName'
	name=EString;
	
//expression support for Mappings
MappingExpression returns AbstractMappingRule:
	ImplicationMapping;

ImplicationMapping returns AbstractMappingRule:
	OrMapping ({ImplicationMappingRule.antecedent=current} '=>' consequent=OrMapping)?;

OrMapping returns AbstractMappingRule:
	AndMapping ({OrMappingRule.rules+=current} '||' rules+=AndMapping)*;

AndMapping returns AbstractMappingRule:
	NotMappingExpression ({AndMappingRule.rules+=current} '&&' rules+=NotMappingExpression)*;

NotMappingExpression returns AbstractMappingRule:
	PrimaryMapping | '!' {NotMappingRule} rule=PrimaryMapping;
  
PrimaryMapping returns AbstractMappingRule:
	MappingRule | '(' MappingExpression ')';
	
	
//expression support for policies
PolicyExpression returns AbstractRule:
	ImplicationPolicy;

ImplicationPolicy returns AbstractRule:
	OrPolicy ({ImplicationRule.antecedent=current} '=>' consequent=OrPolicy)?;

OrPolicy returns AbstractRule:
	AndPolicy ({OrRule.rules+=current} '||' rules+=AndPolicy)*;

AndPolicy returns AbstractRule:
	NotExpression ({AndRule.rules+=current} '&&' rules+=NotExpression)*;

NotExpression returns AbstractRule:
   Primary | '!' {NotRule} rule=Primary;
  
Primary returns AbstractRule:
	PolicyRule | '(' PolicyExpression ')';
	
	